Relacionamentos N:N
Nos relacionamentos N:N, existem algumas diferen√ßas significativas ao se criar as associa√ß√µes. Esse tipo de relacionamento pode ser visto tamb√©m como dois relacionamentos um para muitos (1:N) ligados por uma tabela intermedi√°ria, chamada de tabela de jun√ß√£o, a qual guarda as informa√ß√µes de como as tabelas se relacionam entre si.

O diagrama abaixo ser√° usado como exemplo:

Representa√ß√£o de um banco N_N relacionamento nn e transactions
Representa√ß√£o de um banco N:N
Esse banco possui 3 tabelas: users, books e users_books. A tabela users_books possui um relacionamento N:N com as demais tabelas. Desta maneira, podemos concluir que:

A tabela users guarda as informa√ß√µes de cada pessoa.
A tabela books guarda as informa√ß√µes de cada livro.
A tabela users_books ir√° agir como uma tabela de jun√ß√£o, guardando a rela√ß√£o de quais pessoas possuem quais livros. Nessa tabela, uma pessoa pode possuir v√°rios livros, enquanto um livro pode pertencer a v√°rias pessoas. Cadastramos o livro uma √∫nica vez na tabela books, assim como a pessoa na tabela users. Gra√ßas a essa tabela, um livro vai poder ser associado de forma livre a v√°rias pessoas, assim como uma √∫nica pessoa poder√° ser associada a v√°rios livros.
A tabela users_books possui dois campos compondo uma chave prim√°ria composta (Para entender melhor o conceito, acesse o conte√∫do ‚ÄúTransformando ideias em um modelo de banco de dados‚Äù, em Database Design - Como modelar um banco de dados), justamente para evitar a redund√¢ncia dos dados, j√° que a tabela n√£o pode receber um conjunto de valores repetido (a pessoa a ser associada com o mesmo livro mais de uma vez).
Bora come√ßar? Para que possamos fazer o setup da aplica√ß√£o, basta entrar em uma nova pasta e executar os comandos abaixo:

Copiar
npm init -y

npm i -E express@4.17.1 nodemon@2.0.15 sequelize@6.3.4 mysql2@2.1.0 dotenv@8.2.0

npm i -D -E sequelize-cli@6.2.0

touch .sequelizerc
echo -e "const path = require('path');

module.exports = {
    'config': path.resolve('src', 'config', 'config.js'),
    'models-path': path.resolve('src', 'models'),
    'seeders-path': path.resolve('src', 'seeders'),
    'migrations-path': path.resolve('src', 'migrations'),
};
" >> .sequelizerc

mkdir src

(cd src && npx sequelize-cli init)

mkdir src/controllers src/services
touch src/app.js
echo -e "const express = require('express');

const app = express();

app.use(express.json());

module.exports = app;
" >> src/app.js
touch src/server.js

echo -e "require('dotenv').config();

const app = require('./app');
const { PORT = 3001 } = process.env;

app.listen(PORT, () => console.log(\`Ouvindo na porta \${PORT}\`));
" >> src/server.js 

touch src/services/userBook.service.js src/controllers/userBook.controller.js
Feito isso, j√° podemos continuar pelo VS Code ü§ü

Agora, realize as configura√ß√µes necess√°rias no seu projeto:

Config: Converta seu arquivo config para um arquivo JavaScript e configure as credenciais de acesso para usarem vari√°veis de ambiente.

Database: Crie o banco de dados com os nomes abaixo para cada situa√ß√£o:

Para desenvolvimento: books_database_development;
Para testes: books_database_test;
Para produ√ß√£o: books_database_production;
.env: Crie na raiz do projeto para configurar suas vari√°veis de ambiente.

models/index: Lembre-se de configurar corretamente esse arquivo para utilizar o config.js.

Tudo pronto! Ent√£o bora aprende como fazer as associa√ß√µes N:N na pr√°tica? üòé

Uma pergunta importante:

Como criamos uma associa√ß√£o que passa por 3 tabelas?

Primeiro, vamos criar o model de User:

Copiar
// src/models/User.js
module.exports = (sequelize, DataTypes) => {
  const User = sequelize.define(
  'User',
  {
    id: { type: DataTypes.INTEGER, primaryKey: true },
    firstName: DataTypes.STRING,
    lastName: DataTypes.STRING,
    age: DataTypes.INTEGER,
  },
  {
    timestamps: false,
    underscored: true,
  },
);

  return User;
};
Agora vamos ao model de Book:

Copiar
// src/models/Book.js
module.exports = (sequelize, DataTypes) => {
  const Book = sequelize.define(
    'Book',
    {
      id: { type: DataTypes.INTEGER, primaryKey: true },
      name: DataTypes.STRING,
      releaseYear: DataTypes.INTEGER,
      totalPages: DataTypes.INTEGER,
    },
    {
      timestamps: false,
      underscored: true,
    }
  );

  return Book;
};
Certo, nada demais at√© o momento.

Vamos agora criar o model de UserBook:

Copiar
// src/models/UserBook.js

module.exports = (sequelize, _DataTypes) => {
  const UserBook = sequelize.define(
    'UserBook',
    {},
    {
      timestamps: false,
      underscored: true,
      tableName: 'users_books',
    },
  );

  return UserBook;
};
Primeiro de tudo, note que n√£o temos nenhum atributo nesse model. Isso √© poss√≠vel porque quando estabelecemos os relacionamentos no banco de dados usando UserBook como tabela de associa√ß√£o, o Sequelize j√° entende que esse model precisa ter os IDs que formam a chave composta das duas tabelas sendo associadas.

Para entender melhor as decis√µes que tomamos para configurar as options do sequelize.define underscored: para acessar a tabela referente a este model, UserBook (em PascalCase) vai ser transformado em snake_case e ter√° seu final pluralizado, transformando em ‚Äúuser_books‚Äù seu valor de acesso;

tableName: decidimos definir o nome da tabela que esse model se refere, para mantermos o padr√£o de nomes do model no singular.

Copiar
// src/models/UserBook.js

// module.exports = (sequelize, _DataTypes) => {
//   const UserBook = sequelize.define(
//     'UserBook',
//     {},
//     {
//       timestamps: false,
//       underscored: true,
//       tableName: 'users_books',
//     },

  UserBook.associate = (models) => {
    models.Book.belongsToMany(models.User, {
      as: 'users',
      through: UserBook,
      foreignKey: 'bookId', // se refere ao id de Book na tabela de `users_books`
      otherKey: 'userId', // se refere a outra chave de `users_books`
    });
    models.User.belongsToMany(models.Book, {
      as: 'books',
      through: UserBook,
      foreignKey: 'userId', // se refere ao id de User na tabela de `users_books`
      otherKey: 'bookId',
    });
  };

// return UserBook;
// };
Depois, temos um novo tipo de relacionamento: o belongsToMany. Esse relacionamento cria um relacionamento do tipo N:N, utilizando o model especificado na op√ß√£o through como tabela de associa√ß√£o. Temos tamb√©m o alias daquela associa√ß√£o, na chave as e, por √∫ltimo, temos os par√¢metros foreignKey e otherKey. Esses dois par√¢metros dizem ao Sequelize qual campo utilizar na tabela de associa√ß√£o para identificar cada uma das entidades.

Lembre-se: foreignKey sempre se refere ao model em que chamamos belongsToMany, enquanto otherKey se refere ao model com o qual estamos criando a associa√ß√£o.

Para testar a aplica√ß√£o, voc√™ deve fazer as devidas altera√ß√µes nos controllers, criar as migrations e os seeders.

Para criar as migrations, utilize os seguintes comandos:

‚ö†Ô∏è Execute-os separadamente para evitar que o timestamp seja o mesmo para as migrations

Copiar
npx sequelize migration:generate --name create-books
npx sequelize migration:generate --name create-users
npx sequelize migration:generate --name create-users-books
E copie o conte√∫do abaixo para seus respectivos arquivos de migration, create-books, create-users e create-user-books:

Copiar
// cole esse c√≥digo dentro do arquivo da migration "books"

module.exports = {
  up: async (queryInterface, Sequelize) => {
    await queryInterface.createTable('books', {
      id: {
        allowNull: false,
        autoIncrement: true,
        primaryKey: true,
        type: Sequelize.INTEGER,
      },
      name: {
        allowNull: false,
        type: Sequelize.STRING,
      },
      releaseYear: {
        allowNull: false,
        type: Sequelize.INTEGER,
        field: 'release_year', // s√≥ precisamos definir explicitamente os campos com nomes compostos, por causa da semelhan√ßa entre camelCase e snake_case
      },
      totalPages: {
        allowNull: false,
        type: Sequelize.INTEGER,
        field: 'total_pages', // ambos come√ßam com letra min√∫scula, quando temos duas palavras que existe diferen√ßa
      },
    });
  },

  down: async (queryInterface, _Sequelize) => {
    await queryInterface.dropTable('books');
  },
};
Copiar
// cole esse c√≥digo dentro do arquivo da migration "users"

module.exports = {
  up: async (queryInterface, Sequelize) => {
    await queryInterface.createTable('users', {
      id: {
        allowNull: false,
        autoIncrement: true,
        primaryKey: true,
        type: Sequelize.INTEGER,
      },
      firstName: {
        allowNull: false,
        type: Sequelize.STRING,
        field: 'first_name',
      },
      lastName: {
        allowNull: false,
        type: Sequelize.STRING,
        field: 'last_name',
      },
      age: {
        allowNull: false,
        type: Sequelize.INTEGER,
      },
    });
  },

  down: async (queryInterface, _Sequelize) => {
    await queryInterface.dropTable('users');
  },
};
üí¨ Como fa√ßo para criar uma chave prim√°ria composta em uma Migration do Sequelize?

A forma mais simples de fazer isso √© indicar quais campos far√£o parte dessa chave composta. Utilizando novamente o par√¢metro primaryKey. No nosso exemplo, ao inv√©s de usar um id √∫nico para tabela, teremos dois campos com par√¢metro primaryKey: true, sendo userId e bookId:

Copiar
// cole esse c√≥digo dentro do arquivo da migration "users-books"

module.exports = {
  up: async (queryInterface, Sequelize) => {
    await queryInterface.createTable('users_books', {
      userId: {
        type: Sequelize.INTEGER,
        field: 'user_id',
        references: {
          model: 'users',
          key: 'id',
        },
        onUpdate: 'CASCADE',
        onDelete: 'CASCADE',
        primaryKey: true,
      },
      bookId: {
        type: Sequelize.INTEGER,
        field: 'book_id',
        references: {
          model: 'books',
          key: 'id',
        },
        onUpdate: 'CASCADE',
        onDelete: 'CASCADE',
        primaryKey: true,
      },
    });
  },

  down: async (queryInterface, _Sequelize) => {
    await queryInterface.dropTable('users_books');
  },
};
O Sequelize vai interpretar mais de um campo com primaryKey, como sendo a parte de uma chave prim√°ria composta, impedindo que combina√ß√µes repetidas possam ser inseridas nessa tabela! Note ainda, que esses campos tamb√©m s√£o chaves estrangeiras, dada suas referencias (references) a outras tabelas.

Depois disso, teremos que criar as seeds com informa√ß√µes para podermos, enfim, testar nossa nova association:

Para evitar problemas com a nomenclatura dos arquivos de seeds, rode os comandos a seguir separadamente.

Copiar
npx sequelize seed:generate --name books
npx sequelize seed:generate --name users
npx sequelize seed:generate --name user-books
Copie os c√≥digos abaixo para seus respectivos arquivos dentro da pasta seeders:

Copiar
// cole esse c√≥digo dentro do arquivo da seed "books"

module.exports = {
  up: async (queryInterface, Sequelize) => {
    return queryInterface.bulkInsert(
      'books',
      [
        { name: 'O que o sol faz com as flores', release_year: 2017, total_pages: 159 },
        { name: 'Ensinando a transgredir: A educa√ß√£o como pr√°tica da liberdade', release_year: 2017, total_pages: 288 },
        { name: 'Cem Anos de Solid√£o', release_year: 1967, total_pages: 419 },
        { name: 'Primeiros Pesadelos', release_year: 2022, total_pages: 300 },
      ],
      {},
    );
  },

  down: async (queryInterface, _Sequelize) => {
    await queryInterface.bulkDelete('books', null, {});
  },
};
Copiar
// cole esse c√≥digo dentro do arquivo da seed "users"

module.exports = {
  up: async (queryInterface, _Sequelize) => {
    return queryInterface.bulkInsert(
      'users',
      [
        {
          first_name: 'Graciliano',
          last_name: 'Ramos',
          age: 61,
        },
        {
          first_name: 'Bren√©',
          last_name: 'Brown',
          age: 56,
        },
        {
          first_name: 'Djamila',
          last_name: 'Ribeiro',
          age: 42,
        },
      ],
      {},
    );
  },

  down: async (queryInterface, _Sequelize) => {
    await queryInterface.bulkDelete('users', null, {});
  },
};
Copiar
// cole esse c√≥digo dentro do arquivo da seed "user-books"

module.exports = {
  up: async (queryInterface, _Sequelize) => {
    return queryInterface.bulkInsert(
      'users_books',
      [
        { user_id: 1, book_id: 1 },
        { user_id: 1, book_id: 3 },
        { user_id: 2, book_id: 1 },
        { user_id: 2, book_id: 2 },
        { user_id: 3, book_id: 1 },
        { user_id: 3, book_id: 2 },
        { user_id: 3, book_id: 3 },
      ],
      {},
    );
  },

  down: async (queryInterface, _Sequelize) => {
    await queryInterface.bulkDelete('users_books', null, {});
  },
};
Depois, utilize o comando abaixo para criar o banco, executar as migrations e as seeds:

Copiar
npx sequelize db:drop
npx sequelize db:create
npx sequelize db:migrate
npx sequelize db:seed:all
Vamos criar um service para recuperar todos os livros de um usu√°rio pelo seu id:

Copiar
// src/services/userBook.service.js

const { User, Book } = require('../models');

const getUsersBooksById = (id) => User.findOne({
  where: { id },
  include: [{ model: Book, as: 'books', through: { attributes: [] } }],
});

module.exports = {
  getUsersBooksById,
};
Agora seu controller:

Copiar
// src/controllers/userBook.controller.js

const userBookService = require('../services/userBook.service');

const getUsersBooksById = async (req, res) => {
  try {
    const { id } = req.params;
    const user = await userBookService.getUsersBooksById(id);

    if (!user)
      return res.status(404).json({ message: 'Pessoa n√£o encontrada' });

    return res.status(200).json(user);
  } catch (e) {
    console.log(e.message);
    res.status(500).json({ message: 'Algo deu errado' });
  }
};

module.exports = {
  getUsersBooksById,
};
Para fazer a requisi√ß√£o, bastaria acrescentar ao src/app.js as seguintes linhas:

Copiar
// const express = require('express');
const userBookController = require('./controllers/userBook.controller');

// const app = express();
// app.use(express.json());

app.get('/userbooks/:id', userBookController.getUsersBooksById);

// module.exports = app;
Agora, fa√ßa uma requisi√ß√£o do tipo GET para o endpoint localhost:3001/userbooks/1 e verifique a resposta para a pessoa.

Nota: a propriedade through: { attributes: [] } deve estar presente, pois sem ela, em cada book, apareceriam todos seus respectivos users. Tente faz√™-lo sem e veja a diferen√ßa no resultado!